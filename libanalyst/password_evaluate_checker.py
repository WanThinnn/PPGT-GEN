# This file aims to evaluate the passwords generated by different models (mainly on Hit Rate and repeat rate).
'''
File này được viết để đánh giá các mật khẩu được tạo ra bởi các mô hình khác nhau (chủ yếu là tỷ lệ trúng và tỷ lệ lặp lại).
Nó sẽ đọc các mật khẩu từ một tệp đầu vào, phân tích chúng thành các phần tử mô tả kiểu ký tự và sau đó tính toán tỷ lệ trúng và tỷ lệ lặp lại của các mật khẩu được tạo ra.

'''
import argparse
import os
import matplotlib
matplotlib.use('Agg')  # Set backend for server environment
import matplotlib.pyplot as plt
import numpy as np
import base64
import io
import time
import traceback

# Set font để tránh warning
plt.rcParams['font.family'] = ['DejaVu Sans', 'Arial', 'sans-serif']

def get_all_files(path, keyWord):
    '''
    Hàm này nhận vào một đường dẫn và từ khóa, tìm tất cả các tệp trong thư mục đó và các thư mục con của nó.
    Nó sẽ trả về một danh sách chứa đường dẫn đầy đủ của tất cả các tệp có chứa từ khóa được chỉ định trong tên tệp.
    
    :param path: đường dẫn đến thư mục cần tìm kiếm
    :param keyWord: từ khóa để tìm kiếm trong tên tệp
    :return: danh sách chứa đường dẫn đầy đủ của tất cả các tệp có chứa từ khóa trong tên tệp
    '''
    files = []
    for root, dirs, filenames in os.walk(path):
        for filename in filenames:
            if keyWord in filename:
                files.append(os.path.join(root, filename))
    return files

def get_gen_passwords(gen_files, isNormal):
    '''
    Hàm này nhận vào danh sách các tệp mật khẩu được tạo ra và một tham số boolean để xác định phương pháp tạo mật khẩu.
    Nó sẽ đọc từng tệp và phân tích các mật khẩu được tạo ra theo phương pháp bình thường hoặc phương pháp khác.
    Nó sẽ trả về một danh sách chứa tất cả các mật khẩu được tạo ra.
    
    :param gen_files: danh sách các tệp mật khẩu được tạo ra
    :param isNormal: tham số boolean để xác định phương pháp tạo mật khẩu
    :return: danh sách chứa tất cả các mật khẩu được tạo ra
    '''
    gen_passwords = []
    for gen_file in gen_files:
        if isNormal:
            with open(gen_file, "r") as f:
                for line in f.readlines():
                    try:
                        gen_passwords.append(line.split(" ")[1])
                    except:
                        continue 
        else:
            with open(gen_file, "r") as f:
                gen_passwords += f.readlines()
    return gen_passwords

def get_hit_rate(test_file, gen_files, isNormal):
    '''
    Hàm này nhận vào đường dẫn đến tệp mật khẩu cần đánh giá và danh sách các tệp mật khẩu được tạo ra.
    Nó sẽ đọc các mật khẩu từ tệp đầu vào và so sánh với các mật khẩu được tạo ra.
    Nó sẽ tính toán tỷ lệ trúng (hit rate) bằng cách chia số lượng mật khẩu trùng khớp cho tổng số mật khẩu trong tệp đầu vào.
    
    :param test_file: đường dẫn đến tệp mật khẩu cần đánh giá
    :param gen_files: danh sách các tệp mật khẩu được tạo ra
    :param isNormal: tham số boolean để xác định phương pháp tạo mật khẩu
    :return: tỷ lệ trúng (hit rate)
    '''
    hit_num = 0
    gen_passwords = get_gen_passwords(gen_files, isNormal)
    gen_passwords = set(gen_passwords)

    with open(test_file, "r") as f:
        test_passwords = f.readlines()
    test_passwords = set(test_passwords)

    for password in gen_passwords:
        if password in test_passwords:
            hit_num += 1
    
    hit_rate = hit_num / len(test_passwords)
    return hit_rate

def get_repeat_rate(gen_files, isNormal):
    '''
    Hàm này nhận vào danh sách các tệp mật khẩu được tạo ra.
    Nó sẽ đọc tất cả các mật khẩu từ các tệp và tính toán tỷ lệ lặp lại (repeat rate) bằng cách chia số lượng mật khẩu trùng lặp cho tổng số mật khẩu được tạo ra.
    
    :param gen_files: danh sách các tệp mật khẩu được tạo ra
    :param isNormal: tham số boolean để xác định phương pháp tạo mật khẩu
    :return: tỷ lệ lặp lại (repeat rate)
    '''
    gen_passwords = get_gen_passwords(gen_files, isNormal)
    _gen_passwords = set(gen_passwords)
    repeat_rate = 1 - len(_gen_passwords) / len(gen_passwords)
    return repeat_rate

# Hàm đánh giá model cho web API
def evaluate_model(test_file_path, gen_path, is_normal):
    """
    Đánh giá hiệu suất model tạo mật khẩu
    
    Args:
        test_file_path (str): Đường dẫn đến file test
        gen_path (str): Đường dẫn đến thư mục chứa file generated
        is_normal (bool): True nếu là Normal mode, False nếu là DC mode
    
    Returns:
        dict: Kết quả đánh giá
    """
    try:
        print(f"evaluate_model called with: test_file_path={test_file_path}, gen_path={gen_path}, is_normal={is_normal}")
        
        # Kiểm tra file test tồn tại
        if not os.path.exists(test_file_path):
            return {'error': f'Test file not found: {test_file_path}'}
        
        # Kiểm tra thư mục gen_path tồn tại
        if not os.path.exists(gen_path):
            return {'error': f'Generated files path not found: {gen_path}'}
        
        keyWord = "Normal" if is_normal else "DC"
        print(f"Looking for files with keyword: {keyWord}")
        
        # Tìm tất cả files generated
        gen_files = []
        if os.path.exists(gen_path):
            for root, dirs, files in os.walk(gen_path):
                for file in files:
                    if keyWord.lower() in file.lower() and file.endswith('.txt'):
                        full_path = os.path.join(root, file)
                        gen_files.append(full_path)
                        print(f"Found generated file: {full_path}")
        
        print(f"Total generated files found: {len(gen_files)}")
        
        if not gen_files:
            return {'error': f'No {keyWord} generated files (.txt) found in {gen_path}'}
        
        # Read test passwords
        test_passwords = set()
        try:
            with open(test_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    password = line.strip()
                    if password:
                        test_passwords.add(password)
        except Exception as e:
            return {'error': f'Error reading test file: {str(e)}'}
        
        print(f"Test passwords loaded: {len(test_passwords)}")
        
        if not test_passwords:
            return {'error': 'No valid passwords found in test file'}
        
        # Read generated passwords
        gen_passwords = []
        for gen_file in gen_files:
            try:
                with open(gen_file, 'r', encoding='utf-8') as f:
                    if is_normal:
                        for line in f:
                            try:
                                # Normal format: "probability password"
                                parts = line.strip().split(" ", 1)
                                if len(parts) >= 2:
                                    password = parts[1]
                                    if password:
                                        gen_passwords.append(password)
                            except:
                                continue
                    else:
                        for line in f:
                            password = line.strip()
                            if password:
                                gen_passwords.append(password)
            except Exception as e:
                print(f"Error reading {gen_file}: {e}")
                continue
        
        print(f"Generated passwords loaded: {len(gen_passwords)}")
        
        if not gen_passwords:
            return {'error': 'No generated passwords found in files'}
        
        # Calculate hit rate
        gen_set = set(gen_passwords)
        hits = len(test_passwords.intersection(gen_set))
        hit_rate = hits / len(test_passwords) if test_passwords else 0
        
        # Calculate repeat rate
        total_generated = len(gen_passwords)
        unique_generated = len(gen_set)
        repeat_rate = 1 - unique_generated / total_generated if total_generated > 0 else 0
        
        # Sample matches
        sample_matches = list(test_passwords.intersection(gen_set))[:20]
        
        print(f"Results - Hit rate: {hit_rate:.4f}, Repeat rate: {repeat_rate:.4f}")
        
        return {
            'hit_rate': hit_rate,
            'repeat_rate': repeat_rate,
            'details': {
                'total_test_passwords': len(test_passwords),
                'total_generated_passwords': total_generated,
                'unique_generated': unique_generated,
                'hits': hits,
                'repeats': total_generated - unique_generated,
                'files_processed': len(gen_files)
            },
            'sample_matches': sample_matches
        }
    
    except Exception as e:
        print(f"Exception in evaluate_model: {str(e)}")
        return {'error': str(e)}

def create_evaluation_charts(result, save_to_file=False):
    """
    Tạo biểu đồ đánh giá model cho web API
    
    Args:
        result: Kết quả từ evaluate_model
        save_to_file: True nếu muốn save file, False nếu return base64
    
    Returns:
        base64 string của hình ảnh hoặc file path
    """
    try:
        # Tạo figure với 2x2 subplot
        plt.style.use('default')
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12), facecolor='white')
        
        # 1. Hit Rate vs Repeat Rate Comparison
        metrics = ['Hit Rate', 'Repeat Rate']
        values = [result['hit_rate'] * 100, result['repeat_rate'] * 100]
        colors = ['#34c759', '#ff3b30']
        
        bars1 = ax1.bar(metrics, values, color=colors, alpha=0.8, width=0.6)
        ax1.set_ylabel('Percentage (%)', fontweight='bold')
        ax1.set_title('Model Performance: Hit Rate vs Repeat Rate', fontweight='bold', pad=20)
        ax1.grid(True, alpha=0.3, axis='y')
        
        # Thêm giá trị trên cột
        for i, bar in enumerate(bars1):
            height = bar.get_height()
            ax1.annotate(f'{height:.4f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=12, fontweight='bold')
        
        # 2. Password Distribution Analysis
        categories = ['Total Test', 'Total Generated', 'Hits', 'Unique Generated', 'Repeats']
        counts = [
            result['details']['total_test_passwords'],
            result['details']['total_generated_passwords'],
            result['details']['hits'],
            result['details']['unique_generated'],
            result['details']['repeats']
        ]
        
        bars2 = ax2.bar(categories, counts, color=['#007AFF', '#5856d6', '#34c759', '#ff9500', '#ff3b30'], alpha=0.8)
        ax2.set_ylabel('Count', fontweight='bold')
        ax2.set_title('Password Distribution Analysis', fontweight='bold', pad=20)
        ax2.tick_params(axis='x', rotation=45)
        ax2.grid(True, alpha=0.3, axis='y')
        
        # Thêm giá trị trên cột
        for bar in bars2:
            height = bar.get_height()
            ax2.annotate(f'{int(height):,}',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=10, fontweight='bold')
        
        # 3. Performance Score Breakdown
        hit_score = min(6, result['hit_rate'] * 100 * 0.3)  # Max 6 points
        repeat_score = max(0, 4 - result['repeat_rate'] * 100 * 0.2)  # Max 4 points
        total_score = hit_score + repeat_score
        
        score_categories = ['Hit Score\n(max 6)', 'Repeat Score\n(max 4)', 'Total Score\n(max 10)']
        score_values = [hit_score, repeat_score, total_score]
        max_values = [6, 4, 10]
        
        x_pos = np.arange(len(score_categories))
        bars3 = ax3.bar(x_pos, score_values, color=['#34c759', '#ff9500', '#5856d6'], alpha=0.8)
        ax3.bar(x_pos, max_values, color='lightgray', alpha=0.3, width=0.5)
        
        ax3.set_ylabel('Score', fontweight='bold')
        ax3.set_title('Performance Score Breakdown', fontweight='bold', pad=20)
        ax3.set_xticks(x_pos)
        ax3.set_xticklabels(score_categories)
        ax3.set_ylim(0, 10)
        ax3.grid(True, alpha=0.3, axis='y')
        
        # Thêm giá trị trên cột
        for i, bar in enumerate(bars3):
            height = bar.get_height()
            ax3.annotate(f'{height:.2f}',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=12, fontweight='bold')
        
        # 4. Efficiency Metrics
        efficiency_score = result['hit_rate'] / (result['repeat_rate'] + 0.001) * 100
        quality_index = (result['hit_rate'] * 100 * result['details']['unique_generated'] / result['details']['total_generated_passwords']) / 100
        coverage_rate = result['details']['hits'] / result['details']['total_test_passwords'] * 100
        
        efficiency_metrics = ['Efficiency\nScore', 'Quality\nIndex', 'Coverage\nRate (%)']
        efficiency_values = [efficiency_score, quality_index * 100, coverage_rate]
        
        bars4 = ax4.bar(efficiency_metrics, efficiency_values, 
                       color=['#af52de', '#5856d6', '#007AFF'], alpha=0.8)
        ax4.set_ylabel('Value', fontweight='bold')
        ax4.set_title('Model Efficiency Metrics', fontweight='bold', pad=20)
        ax4.grid(True, alpha=0.3, axis='y')
        
        # Thêm giá trị trên cột
        for i, bar in enumerate(bars4):
            height = bar.get_height()
            if i == 1:  # Quality Index
                ax4.annotate(f'{height:.4f}',
                            xy=(bar.get_x() + bar.get_width() / 2, height),
                            xytext=(0, 3),
                            textcoords="offset points",
                            ha='center', va='bottom',
                            fontsize=11, fontweight='bold')
            else:
                ax4.annotate(f'{height:.2f}',
                            xy=(bar.get_x() + bar.get_width() / 2, height),
                            xytext=(0, 3),
                            textcoords="offset points",
                            ha='center', va='bottom',
                            fontsize=11, fontweight='bold')
        
        # Tổng title cho toàn bộ figure
        mode_text = "Normal Mode" if result.get('is_normal', True) else "DC Mode"
        fig.suptitle(f'Password Model Evaluation Report - {mode_text}\nGenerated at: {result.get("timestamp", "N/A")}', 
                    fontsize=16, fontweight='bold', y=0.98)
        
        plt.tight_layout()
        plt.subplots_adjust(top=0.92)
        
        if save_to_file:
            # Save to file
            chart_path = f"static/charts/evaluation_{int(time.time())}.png"
            os.makedirs(os.path.dirname(chart_path), exist_ok=True)
            plt.savefig(chart_path, dpi=150, bbox_inches='tight', facecolor='white')
            plt.close(fig)
            return chart_path
        else:
            # Return base64 string
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            buffer.seek(0)
            image_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
            plt.close(fig)
            buffer.close()
            return image_base64
            
    except Exception as e:
        print(f"Error creating evaluation charts: {e}")
        traceback.print_exc()
        return None

def create_comparison_evaluation_chart(results_list, labels, save_to_file=False):
    """
    Tạo biểu đồ so sánh nhiều model
    
    Args:
        results_list: List các kết quả đánh giá
        labels: List tên các model
        save_to_file: True nếu muốn save file, False nếu return base64
    
    Returns:
        base64 string của hình ảnh hoặc file path
    """
    try:
        plt.style.use('default')
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6), facecolor='white')
        
        # Extract data
        hit_rates = [r['hit_rate'] * 100 for r in results_list]
        repeat_rates = [r['repeat_rate'] * 100 for r in results_list]
        
        # Chart 1: Hit Rate Comparison
        x = np.arange(len(labels))
        width = 0.35
        
        bars1 = ax1.bar(x, hit_rates, width, label='Hit Rate (%)', 
                       color='#34c759', alpha=0.8)
        
        ax1.set_xlabel('Models', fontweight='bold')
        ax1.set_ylabel('Hit Rate (%)', fontweight='bold')
        ax1.set_title('Hit Rate Comparison Across Models', fontweight='bold', pad=20)
        ax1.set_xticks(x)
        ax1.set_xticklabels(labels)
        ax1.grid(True, alpha=0.3, axis='y')
        
        # Add values on bars
        for bar in bars1:
            height = bar.get_height()
            ax1.annotate(f'{height:.4f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=10, fontweight='bold')
        
        # Chart 2: Repeat Rate Comparison
        bars2 = ax2.bar(x, repeat_rates, width, label='Repeat Rate (%)', 
                       color='#ff3b30', alpha=0.8)
        
        ax2.set_xlabel('Models', fontweight='bold')
        ax2.set_ylabel('Repeat Rate (%)', fontweight='bold')
        ax2.set_title('Repeat Rate Comparison Across Models', fontweight='bold', pad=20)
        ax2.set_xticks(x)
        ax2.set_xticklabels(labels)
        ax2.grid(True, alpha=0.3, axis='y')
        
        # Add values on bars
        for bar in bars2:
            height = bar.get_height()
            ax2.annotate(f'{height:.4f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom',
                        fontsize=10, fontweight='bold')
        
        plt.tight_layout()
        
        if save_to_file:
            chart_path = f"static/charts/evaluation_comparison_{int(time.time())}.png"
            os.makedirs(os.path.dirname(chart_path), exist_ok=True)
            plt.savefig(chart_path, dpi=150, bbox_inches='tight', facecolor='white')
            plt.close(fig)
            return chart_path
        else:
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            buffer.seek(0)
            image_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
            plt.close(fig)
            buffer.close()
            return image_base64
            
    except Exception as e:
        print(f"Error creating comparison evaluation chart: {e}")
        traceback.print_exc()
        return None

# ...existing code...
