/* filepath: /mnt/d/Documents/UIT/Nam_3/HK2/NT522_AI-ATTT/PPGT-GEN/static/js/evaluate_checker.js */
const form = document.getElementById('evaluate-form');
const submitBtn = document.getElementById('submit-btn');
const cancelBtn = document.getElementById('cancel-btn');
const btnText = document.getElementById('btn-text');
const testFileInput = document.getElementById('test-file');
const genPathInput = document.getElementById('gen-path');
const modeButtons = document.querySelectorAll('.mode-btn');
const modeInfos = document.querySelectorAll('.mode-info');

let currentMode = 'normal';
let checkStartTime = null;
let isProcessing = false;
let currentController = null;

// Mode switching
modeButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const mode = btn.dataset.mode;
    switchMode(mode);
  });
});

function switchMode(mode) {
  currentMode = mode;
  
  // Update active button
  modeButtons.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  
  // Update mode info
  modeInfos.forEach(info => {
    info.classList.toggle('active', info.classList.contains(`${mode}-mode`));
  });
  
  // Update button text
  btnText.textContent = 'B·∫Øt ƒë·∫ßu ƒë√°nh gi√°';
}

// Cancel button functionality
cancelBtn.addEventListener('click', async () => {
  if (!isProcessing) return;
  
  try {
    if (currentController) {
      currentController.abort();
    }
    
    resetToInitialState();
    
    const resultElement = document.getElementById('result');
    const statusBadge = document.getElementById('status-badge');
    
    resultElement.textContent = `‚ùå Qu√° tr√¨nh ƒë√°nh gi√° ƒë√£ b·ªã h·ªßy b·ªüi ng∆∞·ªùi d√πng\n\nTh·ªùi gian h·ªßy: ${new Date().toLocaleString()}`;
    statusBadge.textContent = 'ƒê√£ h·ªßy';
    statusBadge.className = 'status-badge status-error';
    
    const checkTime = checkStartTime ? 
      Math.round((Date.now() - checkStartTime) / 1000) : 0;
    document.getElementById('check-time').textContent = `${checkTime}s`;
    
    showResult();
    
  } catch (error) {
    console.error('Error during cancellation:', error);
  }
});

function showResult() {
  document.getElementById('result-placeholder').classList.add('hidden');
  document.getElementById('result-content').classList.add('show');
  
  document.querySelector('.container').classList.add('has-result');
  
  const modeIndicator = document.getElementById('mode-indicator');
  const modeIcon = currentMode === 'normal' ? '‚öñÔ∏è' : 'üß†';
  const modeText = currentMode === 'normal' ? 'Normal' : 'DC';
  modeIndicator.textContent = `${modeIcon} ${modeText}`;
}

function hideResult() {
  document.getElementById('result-placeholder').classList.remove('hidden');
  document.getElementById('result-content').classList.remove('show');
  
  document.querySelector('.container').classList.remove('has-result');
}

function setProcessingState(processing) {
  isProcessing = processing;
  
  if (processing) {
    submitBtn.classList.add('loading');
    submitBtn.disabled = true;
    cancelBtn.classList.add('show');
    btnText.textContent = 'ƒêang ƒë√°nh gi√°...';
  } else {
    submitBtn.classList.remove('loading');
    submitBtn.disabled = false;
    cancelBtn.classList.remove('show');
    btnText.textContent = 'B·∫Øt ƒë·∫ßu ƒë√°nh gi√°';
  }
}

function resetToInitialState() {
  setProcessingState(false);
  checkStartTime = null;
  currentController = null;
}

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  if (isProcessing) return;
  
  checkStartTime = Date.now();
  setProcessingState(true);
  
  currentController = new AbortController();

  try {
    const formData = new FormData();
    formData.append('test_file', testFileInput.files[0]);
    formData.append('gen_path', genPathInput.value);
    formData.append('is_normal', currentMode === 'normal' ? 'true' : 'false');
    
    const requestOptions = {
      method: 'POST',
      signal: currentController.signal,
      body: formData
    };

    const res = await fetch('/evaluate_password_model', requestOptions);
    
    if (!res.ok) {
      throw new Error(`HTTP Error: ${res.status}`);
    }
    
    const result = await res.json();
    displayResult(result, true);

  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled');
      return;
    }
    
    const checkTime = checkStartTime ? 
      Math.round((Date.now() - checkStartTime) / 1000) : 0;
    document.getElementById('check-time').textContent = `${checkTime}s`;
    
    document.getElementById('result').textContent = `‚ùå L·ªói: ${error.message}`;
    document.getElementById('status-badge').textContent = 'L·ªói';
    document.getElementById('status-badge').className = 'status-badge status-error';
    showResult();
  } finally {
    setProcessingState(false);
    currentController = null;
  }
});

// Th√™m event listeners cho chart functionality
document.getElementById('chart-btn').addEventListener('click', toggleChart);
document.getElementById('chart-toggle-btn').addEventListener('click', hideChart);

function toggleChart() {
  const chartContainer = document.getElementById('chart-container');
  const chartBtn = document.getElementById('chart-btn');
  
  if (chartContainer.style.display === 'none') {
    chartContainer.style.display = 'block';
    chartBtn.innerHTML = 'üìä ·∫®n bi·ªÉu ƒë·ªì';
  } else {
    hideChart();
  }
}

function hideChart() {
  const chartContainer = document.getElementById('chart-container');
  const chartBtn = document.getElementById('chart-btn');
  
  chartContainer.classList.add('hiding');
  setTimeout(() => {
    chartContainer.style.display = 'none';
    chartContainer.classList.remove('hiding');
    chartBtn.innerHTML = 'üìä Bi·ªÉu ƒë·ªì';
  }, 300);
}

function displayResult(result, isSuccess) {
  window.lastEvaluateResult = result;
  
  const checkTime = checkStartTime ? 
    Math.round((Date.now() - checkStartTime) / 1000) : 0;
  document.getElementById('check-time').textContent = `${checkTime}s`;
  
  const resultElement = document.getElementById('result');
  const statusBadge = document.getElementById('status-badge');
  const chartBtn = document.getElementById('chart-btn');
  const chartImage = document.getElementById('chart-image');
  
  // TH√äM: X·ª≠ l√Ω bi·ªÉu ƒë·ªì
  if (result.chart) {
    chartBtn.style.display = 'inline-block';
    chartImage.src = `data:image/png;base64,${result.chart}`;
    
    // Auto show chart for first time
    setTimeout(() => {
      if (document.getElementById('chart-container').style.display === 'none') {
        toggleChart();
      }
    }, 500);
  } else {
    chartBtn.style.display = 'none';
    document.getElementById('chart-container').style.display = 'none';
  }
  
  let resultText = `‚öñÔ∏è B√ÅO C√ÅO ƒê√ÅNH GI√Å MODEL T·∫†O M·∫¨T KH·∫®U\n`;
  resultText += `Th·ªùi gian: ${result.timestamp}\n`;
  resultText += `Mode: ${currentMode.toUpperCase()}\n`;
  resultText += `Test file: ${result.test_file}\n`;
  resultText += `Generated path: ${result.gen_path}\n`;
  resultText += `${'='.repeat(60)}\n\n`;
  
  resultText += `üìä K·∫æT QU·∫¢ ƒê√ÅNH GI√Å:\n`;
  
  // FIXED: Hi·ªÉn th·ªã gi√° tr·ªã ch√≠nh x√°c v·ªõi nhi·ªÅu ch·ªØ s·ªë th·∫≠p ph√¢n h∆°n
  const hitRateRaw = result.hit_rate;
  const repeatRateRaw = result.repeat_rate;
  
  // Hi·ªÉn th·ªã gi√° tr·ªã raw v·ªõi 15 ch·ªØ s·ªë th·∫≠p ph√¢n
  resultText += `Hit Rate: ${hitRateRaw.toFixed(15)}\n`;
  resultText += `Hit Rate (%): ${(hitRateRaw * 100).toFixed(12)}%\n`;
  resultText += `Repeat Rate: ${repeatRateRaw.toFixed(15)}\n`;
  resultText += `Repeat Rate (%): ${(repeatRateRaw * 100).toFixed(12)}%\n\n`;
  
  // TH√äM: Scientific notation n·∫øu s·ªë qu√° nh·ªè
  if (repeatRateRaw < 0.001) {
    resultText += `üìã SCIENTIFIC NOTATION:\n`;
    resultText += `Hit Rate: ${hitRateRaw.toExponential(8)}\n`;
    resultText += `Repeat Rate: ${repeatRateRaw.toExponential(8)}\n\n`;
  }
  
  // TH√äM: Th√¥ng b√°o v·ªÅ bi·ªÉu ƒë·ªì
  if (result.chart) {
    resultText += `üìä BI·ªÇU ƒê·ªí PH√ÇN T√çCH:\n`;
    resultText += `‚úÖ Bi·ªÉu ƒë·ªì chi ti·∫øt ƒë√£ ƒë∆∞·ª£c t·∫°o - nh·∫•n n√∫t "üìä Bi·ªÉu ƒë·ªì" ƒë·ªÉ xem\n`;
    resultText += `   ‚Ä¢ Hit Rate vs Repeat Rate comparison\n`;
    resultText += `   ‚Ä¢ Password distribution analysis\n`;
    resultText += `   ‚Ä¢ Performance score breakdown\n`;
    resultText += `   ‚Ä¢ Model efficiency metrics\n\n`;
  }
  
  // Ph√¢n t√≠ch chi ti·∫øt
  resultText += `üìà PH√ÇN T√çCH CHI TI·∫æT:\n`;
  resultText += `T·ªïng s·ªë m·∫≠t kh·∫©u test: ${result.details.total_test_passwords.toLocaleString()}\n`;
  resultText += `T·ªïng s·ªë m·∫≠t kh·∫©u generated: ${result.details.total_generated_passwords.toLocaleString()}\n`;
  resultText += `S·ªë m·∫≠t kh·∫©u tr√∫ng: ${result.details.hits.toLocaleString()}\n`;
  resultText += `S·ªë m·∫≠t kh·∫©u unique trong generated: ${result.details.unique_generated.toLocaleString()}\n`;
  resultText += `S·ªë m·∫≠t kh·∫©u l·∫∑p l·∫°i: ${result.details.repeats.toLocaleString()}\n`;
  resultText += `S·ªë file ƒë√£ x·ª≠ l√Ω: ${result.details.files_processed}\n\n`;
  
  // Th√™m th√¥ng tin chi ti·∫øt h∆°n v·ªõi ƒë·ªô ch√≠nh x√°c cao
  resultText += `üîç TH√îNG TIN CHI TI·∫æT (ƒê·ªò CH√çNH X√ÅC CAO):\n`;
  const hitRatePercent = hitRateRaw * 100;
  const repeatRatePercent = repeatRateRaw * 100;
  const uniqueRatio = (result.details.unique_generated / result.details.total_generated_passwords) * 100;
  
  resultText += `T·ª∑ l·ªá unique trong generated: ${uniqueRatio.toFixed(10)}%\n`;
  resultText += `T·ª∑ l·ªá hit tr√™n t·ªïng generated: ${(result.details.hits / result.details.total_generated_passwords * 100).toFixed(10)}%\n`;
  resultText += `T·ª∑ l·ªá coverage test set: ${(result.details.hits / result.details.total_test_passwords * 100).toFixed(10)}%\n\n`;
  
  // ƒê√°nh gi√° hi·ªáu su·∫•t v·ªõi ƒë·ªô ch√≠nh x√°c cao
  resultText += `üéØ ƒê√ÅNH GI√Å HI·ªÜU SU·∫§T (ƒê·ªò CH√çNH X√ÅO CAO):\n`;
  
  // Hit Rate evaluation v·ªõi nhi·ªÅu ch·ªØ s·ªë
  if (hitRatePercent >= 15) {
    resultText += `‚úÖ Hit Rate: Xu·∫•t s·∫Øc (‚â•15.000000%) - Actual: ${hitRatePercent.toFixed(8)}%\n`;
  } else if (hitRatePercent >= 10) {
    resultText += `üü° Hit Rate: T·ªët (10.000000-15.000000%) - Actual: ${hitRatePercent.toFixed(8)}%\n`;
  } else if (hitRatePercent >= 5) {
    resultText += `üü† Hit Rate: Trung b√¨nh (5.000000-10.000000%) - Actual: ${hitRatePercent.toFixed(8)}%\n`;
  } else if (hitRatePercent >= 1) {
    resultText += `üî¥ Hit Rate: Y·∫øu (1.000000-5.000000%) - Actual: ${hitRatePercent.toFixed(8)}%\n`;
  } else {
    resultText += `üíÄ Hit Rate: R·∫•t y·∫øu (<1.000000%) - Actual: ${hitRatePercent.toFixed(8)}%\n`;
  }
  
  // Repeat Rate evaluation v·ªõi ƒë·ªô ch√≠nh x√°c c·ª±c cao
  if (repeatRatePercent <= 0.000001) {
    resultText += `‚úÖ Repeat Rate: Xu·∫•t s·∫Øc (‚â§0.000001%) - Actual: ${repeatRatePercent.toFixed(10)}%\n`;
  } else if (repeatRatePercent <= 0.001) {
    resultText += `üü¢ Repeat Rate: R·∫•t t·ªët (‚â§0.001000%) - Actual: ${repeatRatePercent.toFixed(10)}%\n`;
  } else if (repeatRatePercent <= 0.1) {
    resultText += `üü° Repeat Rate: T·ªët (‚â§0.100000%) - Actual: ${repeatRatePercent.toFixed(8)}%\n`;
  } else if (repeatRatePercent <= 1) {
    resultText += `üü† Repeat Rate: Trung b√¨nh (‚â§1.000000%) - Actual: ${repeatRatePercent.toFixed(8)}%\n`;
  } else if (repeatRatePercent <= 5) {
    resultText += `üî¥ Repeat Rate: Y·∫øu (1.000000-5.000000%) - Actual: ${repeatRatePercent.toFixed(8)}%\n`;
  } else {
    resultText += `üíÄ Repeat Rate: R·∫•t y·∫øu (>5.000000%) - Actual: ${repeatRatePercent.toFixed(8)}%\n`;
  }
  
  // Overall score
  const overallScore = calculateOverallScore(result.hit_rate, result.repeat_rate);
  resultText += `\nüèÜ ƒêI·ªÇM T·ªîNG TH·ªÇ: ${overallScore.score.toFixed(4)}/10.0000 (${overallScore.grade})\n`;
  
  // Th√™m th√¥ng tin v·ªÅ efficiency v·ªõi ƒë·ªô ch√≠nh x√°c cao
  resultText += `\nüìä HI·ªÜU SU·∫§T (ƒê·ªò CH√çNH X√ÅC CAO):\n`;
  const efficiencyScore = hitRateRaw / (repeatRateRaw + 0.000000001) * 100;
  const qualityIndex = (hitRatePercent * uniqueRatio) / 10000;
  
  resultText += `Efficiency Score: ${efficiencyScore.toFixed(6)}\n`;
  resultText += `Quality Index: ${qualityIndex.toFixed(10)}\n`;
  
  // TH√äM: Raw data section
  resultText += `\nüî¨ RAW DATA (EXACT VALUES):\n`;
  resultText += `Hit Rate (raw): ${hitRateRaw}\n`;
  resultText += `Repeat Rate (raw): ${repeatRateRaw}\n`;
  resultText += `Hit Rate (scientific): ${hitRateRaw.toExponential(12)}\n`;
  resultText += `Repeat Rate (scientific): ${repeatRateRaw.toExponential(12)}\n`;
  
  // Recommendations v·ªõi th√¥ng tin chi ti·∫øt h∆°n
  resultText += `\nüí° KHUY·∫æN NGH·ªä CHI TI·∫æT:\n`;
  if (hitRatePercent < 1) {
    resultText += `  üî• CRITICAL: Hit Rate r·∫•t th·∫•p (${hitRatePercent.toFixed(8)}%), c·∫ßn training l·∫°i model\n`;
  } else if (hitRatePercent < 5) {
    resultText += `  ‚ö†Ô∏è  WARNING: Hit Rate th·∫•p (${hitRatePercent.toFixed(8)}%), c·∫ßn fine-tune model\n`;
  } else if (hitRatePercent < 10) {
    resultText += `  ‚ÑπÔ∏è  INFO: Hit Rate c√≥ th·ªÉ c·∫£i thi·ªán (${hitRatePercent.toFixed(8)}%)\n`;
  } else {
    resultText += `  ‚úÖ GOOD: Hit Rate ƒë·∫°t m·ª©c t·ªët (${hitRatePercent.toFixed(8)}%)\n`;
  }
  
  if (repeatRatePercent > 1) {
    resultText += `  üî• CRITICAL: Repeat Rate cao (${repeatRatePercent.toFixed(8)}%), c·∫ßn tƒÉng diversity\n`;
  } else if (repeatRatePercent > 0.1) {
    resultText += `  ‚ö†Ô∏è  WARNING: Repeat Rate h∆°i cao (${repeatRatePercent.toFixed(8)}%)\n`;
  } else if (repeatRatePercent < 0.000001) {
    resultText += `  ‚úÖ EXCELLENT: Repeat Rate c·ª±c th·∫•p (${repeatRatePercent.toFixed(10)}%), diversity xu·∫•t s·∫Øc\n`;
  } else {
    resultText += `  ‚úÖ GOOD: Repeat Rate th·∫•p (${repeatRatePercent.toFixed(8)}%), diversity t·ªët\n`;
  }
  
  if (hitRatePercent >= 5 && repeatRatePercent <= 0.1) {
    resultText += `  üéâ Model ƒëang ho·∫°t ƒë·ªông r·∫•t t·ªët v·ªõi hit rate cao v√† repeat rate th·∫•p!\n`;
  }
  
  // Show sample matches if available
  if (result.sample_matches && result.sample_matches.length > 0) {
    resultText += `\nüìù M·∫™U M·∫¨T KH·∫®U TR√öNG (${Math.min(15, result.sample_matches.length)} m·∫´u ƒë·∫ßu ti√™n):\n`;
    result.sample_matches.slice(0, 15).forEach((password, index) => {
      resultText += `  ${(index + 1).toString().padStart(2, '0')}. ${password}\n`;
    });
    
    if (result.sample_matches.length > 15) {
      resultText += `  ... v√† ${result.sample_matches.length - 15} m·∫≠t kh·∫©u kh√°c\n`;
    }
  }
  
  // Th√™m timestamp v√† signature
  resultText += `\n${'='.repeat(60)}\n`;
  if (result.chart) {
    resultText += `üìä Bi·ªÉu ƒë·ªì ph√¢n t√≠ch chi ti·∫øt c√≥ s·∫µn - xem ph√≠a tr√™n\n`;
  }
  resultText += `Generated by PagPassGPT Evaluator v1.0\n`;
  resultText += `Report generated at: ${new Date().toISOString()}\n`;
  resultText += `High-precision evaluation results preserved\n`;
  
  resultElement.textContent = resultText;
  
  // Set status badge based on overall performance v·ªõi logic chi ti·∫øt h∆°n
  if (overallScore.score >= 9) {
    statusBadge.textContent = 'Ho√†n h·∫£o';
    statusBadge.className = 'status-badge status-excellent';
  } else if (overallScore.score >= 7) {
    statusBadge.textContent = 'Xu·∫•t s·∫Øc';
    statusBadge.className = 'status-badge status-excellent';
  } else if (overallScore.score >= 5) {
    statusBadge.textContent = 'T·ªët';
    statusBadge.className = 'status-badge status-good';
  } else if (overallScore.score >= 3) {
    statusBadge.textContent = 'Trung b√¨nh';
    statusBadge.className = 'status-badge status-average';
  } else {
    statusBadge.textContent = 'Y·∫øu';
    statusBadge.className = 'status-badge status-poor';
  }
  
  showResult();
}

function calculateOverallScore(hitRate, repeatRate) {
  // Hit rate component (0-6 points, higher is better) - scale m·ªü r·ªông v·ªõi ƒë·ªô ch√≠nh x√°c cao
  let hitScore = 0;
  const hitPercent = hitRate * 100;
  if (hitPercent >= 20) hitScore = 6;
  else if (hitPercent >= 15) hitScore = 5.5;
  else if (hitPercent >= 10) hitScore = 5;
  else if (hitPercent >= 5) hitScore = 4;
  else if (hitPercent >= 2) hitScore = 3;
  else if (hitPercent >= 1) hitScore = 2;
  else if (hitPercent >= 0.5) hitScore = 1.5;
  else if (hitPercent >= 0.1) hitScore = 1;
  else hitScore = 0.5;
  
  // Repeat rate component (0-4 points, lower is better) - scale chi ti·∫øt h∆°n v·ªõi ƒë·ªô ch√≠nh x√°c cao
  let repeatScore = 0;
  const repeatPercent = repeatRate * 100;
  if (repeatPercent <= 0.000001) repeatScore = 4;        // G·∫ßn nh∆∞ ho√†n h·∫£o
  else if (repeatPercent <= 0.00001) repeatScore = 3.8;  // Xu·∫•t s·∫Øc
  else if (repeatPercent <= 0.0001) repeatScore = 3.6;   // R·∫•t t·ªët
  else if (repeatPercent <= 0.001) repeatScore = 3.4;    // T·ªët
  else if (repeatPercent <= 0.01) repeatScore = 3.2;     // Kh√° t·ªët
  else if (repeatPercent <= 0.1) repeatScore = 3;        // ·ªîn
  else if (repeatPercent <= 1) repeatScore = 2;          // Trung b√¨nh
  else if (repeatPercent <= 5) repeatScore = 1;          // Y·∫øu
  else repeatScore = 0;                                   // R·∫•t y·∫øu
  
  const totalScore = hitScore + repeatScore;
  
  let grade = '';
  if (totalScore >= 9.5) grade = 'A+';
  else if (totalScore >= 9) grade = 'A';
  else if (totalScore >= 8.5) grade = 'A-';
  else if (totalScore >= 8) grade = 'B+';
  else if (totalScore >= 7) grade = 'B';
  else if (totalScore >= 6) grade = 'B-';
  else if (totalScore >= 5) grade = 'C+';
  else if (totalScore >= 4) grade = 'C';
  else if (totalScore >= 3) grade = 'C-';
  else if (totalScore >= 2) grade = 'D';
  else grade = 'F';
  
  return { score: totalScore, grade };
}

// Copy button functionality
document.getElementById('copy-btn').addEventListener('click', async () => {
  try {
    const resultElement = document.getElementById('result');
    await navigator.clipboard.writeText(resultElement.textContent);
    const btn = document.getElementById('copy-btn');
    const originalText = btn.textContent;
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  } catch (err) {
    console.error('Failed to copy:', err);
  }
});

// Download button functionality
document.getElementById('download-btn').addEventListener('click', async () => {
  try {
    const content = document.getElementById('result').textContent;
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `model-evaluation-${currentMode}-${Date.now()}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    const btn = document.getElementById('download-btn');
    const originalText = btn.textContent;
    btn.textContent = '‚úÖ Downloaded!';
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  } catch (err) {
    console.error('Failed to download:', err);
  }
});

// Initialize default mode
switchMode('normal');